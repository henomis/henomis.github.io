<!doctype html><html lang=it dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Leveraging Go and Redis for Efficient Retrieval Augmented Generation | Simone Vellei Blog</title><meta name=keywords content="lingoose,ai,openai,rag,llm"><meta name=description content="Introduction Artificial Intelligence has transformed the way we handle data, and one crucial aspect of AI is similarity search. Whether it&rsquo;s for image recognition, recommendation systems, or natural language processing, finding similar data points quickly and accurately is a common challenge. In this blog post, we will explore a Go code snippet that showcases how to perform efficient vector similarity search using Redis and the Lingoose Go framework, catering to tech-savvy readers interested in both Go programming and AI."><meta name=author content="Simone Vellei"><link rel=canonical href=https://simonevellei.com/blog/posts/leveraging-go-and-redis-for-efficient-retrieval-augmented-generation/><script>location.protocol!=="https:"&&(location.hostname==="localhost"||location.hostname==="127.0.0.1"||location.replace(`https:${location.href.substring(location.protocol.length)}`))</script><link crossorigin=anonymous href=/blog/assets/css/stylesheet.min.css rel="preload stylesheet" as=style><link rel=preload href=/blog/apple-touch-icon.png as=image><script defer crossorigin=anonymous src=/blog/assets/js/highlight.min.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://simonevellei.com/blog/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://simonevellei.com/blog/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://simonevellei.com/blog/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://simonevellei.com/blog/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://simonevellei.com/blog/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="Leveraging Go and Redis for Efficient Retrieval Augmented Generation"><meta property="og:description" content="Introduction Artificial Intelligence has transformed the way we handle data, and one crucial aspect of AI is similarity search. Whether it&rsquo;s for image recognition, recommendation systems, or natural language processing, finding similar data points quickly and accurately is a common challenge. In this blog post, we will explore a Go code snippet that showcases how to perform efficient vector similarity search using Redis and the Lingoose Go framework, catering to tech-savvy readers interested in both Go programming and AI."><meta property="og:type" content="article"><meta property="og:url" content="https://simonevellei.com/blog/posts/leveraging-go-and-redis-for-efficient-retrieval-augmented-generation/"><meta property="og:image" content="https://simonevellei.com/blog/images/lingoose001.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-11-05T17:06:47+01:00"><meta property="article:modified_time" content="2023-11-05T17:06:47+01:00"><meta property="og:site_name" content="Simone Vellei Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://simonevellei.com/blog/images/lingoose001.png"><meta name=twitter:title content="Leveraging Go and Redis for Efficient Retrieval Augmented Generation"><meta name=twitter:description content="Introduction Artificial Intelligence has transformed the way we handle data, and one crucial aspect of AI is similarity search. Whether it&rsquo;s for image recognition, recommendation systems, or natural language processing, finding similar data points quickly and accurately is a common challenge. In this blog post, we will explore a Go code snippet that showcases how to perform efficient vector similarity search using Redis and the Lingoose Go framework, catering to tech-savvy readers interested in both Go programming and AI."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://simonevellei.com/blog/posts/"},{"@type":"ListItem","position":3,"name":"Leveraging Go and Redis for Efficient Retrieval Augmented Generation","item":"https://simonevellei.com/blog/posts/leveraging-go-and-redis-for-efficient-retrieval-augmented-generation/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Leveraging Go and Redis for Efficient Retrieval Augmented Generation","name":"Leveraging Go and Redis for Efficient Retrieval Augmented Generation","description":"Introduction Artificial Intelligence has transformed the way we handle data, and one crucial aspect of AI is similarity search. Whether it\u0026rsquo;s for image recognition, recommendation systems, or natural language processing, finding similar data points quickly and accurately is a common challenge. In this blog post, we will explore a Go code snippet that showcases how to perform efficient vector similarity search using Redis and the Lingoose Go framework, catering to tech-savvy readers interested in both Go programming and AI.","keywords":["lingoose","ai","openai","rag","llm"],"articleBody":"Introduction Artificial Intelligence has transformed the way we handle data, and one crucial aspect of AI is similarity search. Whether it’s for image recognition, recommendation systems, or natural language processing, finding similar data points quickly and accurately is a common challenge. In this blog post, we will explore a Go code snippet that showcases how to perform efficient vector similarity search using Redis and the Lingoose Go framework, catering to tech-savvy readers interested in both Go programming and AI.\nVector Similarity Search Vector similarity search is a fundamental AI concept that involves finding items similar to a query vector in a large dataset. It is widely used in recommendation systems (e.g., suggesting products or content similar to what a user likes), image and document retrieval, and more. The code snippet we’ll examine demonstrates how to set up a Redis-based vector index and efficiently search for similar vectors.\nAdvantages of Redis for Vector Search Redis, an in-memory key-value store, is a powerful choice for vector similarity search due to its low-latency performance and ability to handle real-time queries. It allows us to store vectors efficiently and perform searches in milliseconds. Redis also offers data persistence and clustering capabilities, making it suitable for large-scale applications.\nImplementing Vector Similarity Search in Go In our code snippet, we use the Lingoose Go framework to create a Redis vector index and perform vector similarity search.\npackage main import ( \"context\" \"fmt\" \"github.com/RediSearch/redisearch-go/v2/redisearch\" \"github.com/henomis/lingoose/index\" \"github.com/henomis/lingoose/index/option\" \"github.com/henomis/lingoose/index/vectordb/redis\" ) func main() { // Create a new redis vector index redisIndex := redis.New( redis.Options{ RedisearchClient: redisearch.NewClient(\"localhost:6379\", \"test\"), CreateIndex: \u0026redis.CreateIndexOptions{ Dimension: 4, Distance: redis.DistanceCosine, }, }, ) // Insert a vector err := redisIndex.Insert( context.Background(), []index.Data{ { ID: \"1\", Values: []float64{0.1, 0.2, 0.3, 0.4}, }, { ID: \"2\", Values: []float64{0.5, 0.6, 0.7, 0.8}, }, }) if err != nil { panic(err) } // Query the index similarities, err := redisIndex.Search( context.Background(), []float64{0.1, 0.8, 0.2, 0.5}, \u0026option.Options{ TopK: 2, }, ) if err != nil { panic(err) } // Print the results for _, similarity := range similarities { fmt.Printf(\"ID: %s, Score: %f\\n\", similarity.ID, similarity.Score) } } Here’s a breakdown of the code:\nImporting Libraries: We import the necessary Go libraries, including Redisearch and Lingoose, to build our vector index.\nCreating the Redis Vector Index: We create a new Redis vector index using the Lingoose library, specifying options such as the Redis server location, the index name, vector dimension, and the distance metric (cosine similarity in this case).\nInserting Vectors: We insert two vectors into the index, each with an ID and a set of float values. This simulates the process of adding data points to the index.\nQuerying the Index: We perform a vector search by providing a query vector and specifying options such as the number of similar vectors to retrieve (TopK).\nPrinting the Results: We print the IDs and similarity scores of the most similar vectors found in the search.\nRetrieval Augmented Generation with Golang and Redis The above code snippet serves as a starting point for implementing vector similarity search in your Go-based AI projects. You can extend this functionality to create recommendation engines, content-based image retrieval systems, or personalized content filtering. In the next example, we’ll use the Lingoose Go framework to build a retrieval augmented generation (RAG) system that uses Redis to store and search for similar vectors.\nLoading PDF Documents docs, _ := loader.NewPDFToTextLoader(\"./kb\"). WithTextSplitter(textsplitter.NewRecursiveCharacterTextSplitter(2000, 200)). Load(context.Background()) The code begins by loading PDF documents from a directory and splitting their text into smaller chunks of 2000 characters. This is a crucial step because it prepares the documents for indexing and querying. The Lingoose loader, textsplitter packages are used here to facilitate this process.\nCreating a Redis Vector Index // Create a new Redis vector index index := index.New( redis.New( redis.Options{ RedisearchClient: redisearch.NewClient(\"localhost:6379\", \"test\"), CreateIndex: \u0026redis.CreateIndexOptions{ Dimension: 1536, Distance: redis.DistanceCosine, }, }, ), openaiembedder.New(openaiembedder.AdaEmbeddingV2), ).WithIncludeContents(true) Next, we create a Redis vector index. We’ve specified parameters such as the dimension (1536) and the distance metric (Cosine) in order to be compliant with our AI LLM engine. The Lingoose openaiembedder package is employed to embed text into vectors, which is essential for AI-based searching. We also set WithIncludeContents to true to include the document contents in the index.\nLoading Documents into the Index index.LoadFromDocuments(context.Background(), docs) Here, we load the documents we previously prepared into the Redis index. This step is where the AI embedding of document content happens, allowing us to perform vector-based searches later.\nQuerying the Index with Q\u0026A qapipeline.New(openai.NewChat().WithVerbose(true)). WithIndex(index). Query(context.Background(), \"What is the NATO purpose?\", option.WithTopK(1)) The final part of the code demonstrates how to use a Q\u0026A pipeline to query the index. We create a Q\u0026A pipeline using OpenAI LLM, and with the help of the WithInde method, we associate it with our Redis index. We then ask a question, “What is the NATO purpose?,” and specify that we want the top 1 answer (WithTopK(1)).\nThe AI-Powered Search Engine in Action So, what does this code snippet achieve? It creates an AI-powered search engine capable of answering questions based on the content of PDF documents. When you pose a question, the search engine scans the indexed documents, computes vector-based similarity, and returns the most relevant answer. This approach is highly versatile and can be used in various real-world scenarios, such as:\nDocument Search: Build a document search engine that helps users find specific information within a large repository of documents.\nChatbots and Virtual Assistants: Enhance chatbots and virtual assistants by enabling them to answer user questions with accuracy, drawing information from knowledge bases.\nE-Learning Platforms: Create intelligent e-learning platforms that can provide instant answers to students’ queries from course materials.\nCustomer Support: Improve customer support systems by automating responses to common questions, providing faster and more accurate support.\nConclusion In this blog post, we’ve explored a Go code that demonstrates the power of combining AI, Redis, and OpenAI to create an intelligent search engine. By embedding document content into vectors and using AI models for querying, you can build a versatile and accurate search engine for a wide range of applications. We used the Lingoose Go framework that I personally developed to provide a simple and efficient way to integrate AI into your Go projects. Experiment with the code and adapt it to your specific needs to unlock the full potential of AI-powered search. AI is constantly evolving, and its applications are limitless, making it an exciting field for tech-savvy Go programmers. Happy coding!\n","wordCount":"1071","inLanguage":"it","image":"https://simonevellei.com/blog/images/lingoose001.png","datePublished":"2023-11-05T17:06:47+01:00","dateModified":"2023-11-05T17:06:47+01:00","author":{"@type":"Person","name":"Simone Vellei"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://simonevellei.com/blog/posts/leveraging-go-and-redis-for-efficient-retrieval-augmented-generation/"},"publisher":{"@type":"Organization","name":"Simone Vellei Blog","logo":{"@type":"ImageObject","url":"https://simonevellei.com/blog/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://simonevellei.com/blog accesskey=h title="Home (Alt + H)"><img src=https://simonevellei.com/blog/apple-touch-icon.png alt=logo aria-label=logo height=35>Home</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://linkedin.com/in/simonevellei><img src=/blog/icons/linkedin.png width=32 height=32 style=margin-top:15px></a></li><li><a href=https://www.instagram.com/simone.vellei.agile><img src=/blog/icons/instagram.png width=32 height=32 style=margin-top:15px></a></li><li><a href="https://www.facebook.com/profile.php?id=100086812039299"><img src=/blog/icons/facebook.png width=32 height=32 style=margin-top:15px></a></li><li><a href=https://www.youtube.com/channel/UCbpAhDsXEEnQlRj6skJR5Nw><img src=/blog/icons/youtube.png width=32 height=32 style=margin-top:15px></a></li><li><a href=https://simonevellei.com/blog/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://simonevellei.com title="Simone Vellei"><span>Simone Vellei</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://simonevellei.com/blog>Home</a>&nbsp;»&nbsp;<a href=https://simonevellei.com/blog/posts/>Posts</a></div><h1 class=post-title>Leveraging Go and Redis for Efficient Retrieval Augmented Generation</h1><div class=post-meta><span title='2023-11-05 17:06:47 +0100 +0100'>novembre 5, 2023</span>&nbsp;·&nbsp;Simone Vellei</div></header><figure class=entry-cover><img loading=lazy src=https://simonevellei.com/blog/images/lingoose001.png alt><p></p></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Tabella dei Contenuti</span></summary><div class=inner><ul><li><a href=#introduction aria-label=Introduction>Introduction</a></li><li><a href=#vector-similarity-search aria-label="Vector Similarity Search">Vector Similarity Search</a></li><li><a href=#advantages-of-redis-for-vector-search aria-label="Advantages of Redis for Vector Search">Advantages of Redis for Vector Search</a></li><li><a href=#implementing-vector-similarity-search-in-go aria-label="Implementing Vector Similarity Search in Go">Implementing Vector Similarity Search in Go</a></li><li><a href=#retrieval-augmented-generation-with-golang-and-redis aria-label="Retrieval Augmented Generation with Golang and Redis">Retrieval Augmented Generation with Golang and Redis</a><ul><li><a href=#loading-pdf-documents aria-label="Loading PDF Documents">Loading PDF Documents</a></li><li><a href=#creating-a-redis-vector-index aria-label="Creating a Redis Vector Index">Creating a Redis Vector Index</a></li><li><a href=#loading-documents-into-the-index aria-label="Loading Documents into the Index">Loading Documents into the Index</a></li><li><a href=#querying-the-index-with-qa aria-label="Querying the Index with Q&amp;amp;A">Querying the Index with Q&amp;A</a></li></ul></li><li><a href=#the-ai-powered-search-engine-in-action aria-label="The AI-Powered Search Engine in Action">The AI-Powered Search Engine in Action</a></li><li><a href=#conclusion aria-label=Conclusion>Conclusion</a></li></ul></div></details></div><div class=post-content><h2 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h2><p>Artificial Intelligence has transformed the way we handle data, and one crucial aspect of AI is similarity search. Whether it&rsquo;s for image recognition, recommendation systems, or natural language processing, finding similar data points quickly and accurately is a common challenge. In this blog post, we will explore a Go code snippet that showcases how to perform efficient vector similarity search using Redis and the <a href=https://github.com/henomis/lingoose>Lingoose</a> Go framework, catering to tech-savvy readers interested in both Go programming and AI.</p><h2 id=vector-similarity-search>Vector Similarity Search<a hidden class=anchor aria-hidden=true href=#vector-similarity-search>#</a></h2><p>Vector similarity search is a fundamental AI concept that involves finding items similar to a query vector in a large dataset. It is widely used in recommendation systems (e.g., suggesting products or content similar to what a user likes), image and document retrieval, and more. The code snippet we&rsquo;ll examine demonstrates how to set up a Redis-based vector index and efficiently search for similar vectors.</p><h2 id=advantages-of-redis-for-vector-search>Advantages of Redis for Vector Search<a hidden class=anchor aria-hidden=true href=#advantages-of-redis-for-vector-search>#</a></h2><p>Redis, an in-memory key-value store, is a powerful choice for vector similarity search due to its low-latency performance and ability to handle real-time queries. It allows us to store vectors efficiently and perform searches in milliseconds. Redis also offers data persistence and clustering capabilities, making it suitable for large-scale applications.</p><h2 id=implementing-vector-similarity-search-in-go>Implementing Vector Similarity Search in Go<a hidden class=anchor aria-hidden=true href=#implementing-vector-similarity-search-in-go>#</a></h2><p>In our code snippet, we use the <a href=https://github.com/henomis/lingoose>Lingoose</a> Go framework to create a Redis vector index and perform vector similarity search.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;context&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;github.com/RediSearch/redisearch-go/v2/redisearch&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;github.com/henomis/lingoose/index&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;github.com/henomis/lingoose/index/option&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;github.com/henomis/lingoose/index/vectordb/redis&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Create a new redis vector index
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>redisIndex</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>redis</span>.<span style=color:#a6e22e>New</span>(
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>redis</span>.<span style=color:#a6e22e>Options</span>{
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>RedisearchClient</span>: <span style=color:#a6e22e>redisearch</span>.<span style=color:#a6e22e>NewClient</span>(<span style=color:#e6db74>&#34;localhost:6379&#34;</span>, <span style=color:#e6db74>&#34;test&#34;</span>),
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>CreateIndex</span>: <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>redis</span>.<span style=color:#a6e22e>CreateIndexOptions</span>{
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>Dimension</span>: <span style=color:#ae81ff>4</span>,
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>Distance</span>:  <span style=color:#a6e22e>redis</span>.<span style=color:#a6e22e>DistanceCosine</span>,
</span></span><span style=display:flex><span>			},
</span></span><span style=display:flex><span>		},
</span></span><span style=display:flex><span>	)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Insert a vector
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>redisIndex</span>.<span style=color:#a6e22e>Insert</span>(
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Background</span>(),
</span></span><span style=display:flex><span>		[]<span style=color:#a6e22e>index</span>.<span style=color:#a6e22e>Data</span>{
</span></span><span style=display:flex><span>			{
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>ID</span>:     <span style=color:#e6db74>&#34;1&#34;</span>,
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>Values</span>: []<span style=color:#66d9ef>float64</span>{<span style=color:#ae81ff>0.1</span>, <span style=color:#ae81ff>0.2</span>, <span style=color:#ae81ff>0.3</span>, <span style=color:#ae81ff>0.4</span>},
</span></span><span style=display:flex><span>			},
</span></span><span style=display:flex><span>			{
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>ID</span>:     <span style=color:#e6db74>&#34;2&#34;</span>,
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>Values</span>: []<span style=color:#66d9ef>float64</span>{<span style=color:#ae81ff>0.5</span>, <span style=color:#ae81ff>0.6</span>, <span style=color:#ae81ff>0.7</span>, <span style=color:#ae81ff>0.8</span>},
</span></span><span style=display:flex><span>			},
</span></span><span style=display:flex><span>		})
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		panic(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Query the index
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>similarities</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>redisIndex</span>.<span style=color:#a6e22e>Search</span>(
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Background</span>(),
</span></span><span style=display:flex><span>		[]<span style=color:#66d9ef>float64</span>{<span style=color:#ae81ff>0.1</span>, <span style=color:#ae81ff>0.8</span>, <span style=color:#ae81ff>0.2</span>, <span style=color:#ae81ff>0.5</span>},
</span></span><span style=display:flex><span>		<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>option</span>.<span style=color:#a6e22e>Options</span>{
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>TopK</span>: <span style=color:#ae81ff>2</span>,
</span></span><span style=display:flex><span>		},
</span></span><span style=display:flex><span>	)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		panic(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Print the results
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>similarity</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>similarities</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;ID: %s, Score: %f\n&#34;</span>, <span style=color:#a6e22e>similarity</span>.<span style=color:#a6e22e>ID</span>, <span style=color:#a6e22e>similarity</span>.<span style=color:#a6e22e>Score</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Here&rsquo;s a breakdown of the code:</p><ol><li><p><strong>Importing Libraries:</strong> We import the necessary Go libraries, including Redisearch and <a href=https://github.com/henomis/lingoose>Lingoose</a>, to build our vector index.</p></li><li><p><strong>Creating the Redis Vector Index:</strong> We create a new Redis vector index using the <a href=https://github.com/henomis/lingoose>Lingoose</a> library, specifying options such as the Redis server location, the index name, vector dimension, and the distance metric (cosine similarity in this case).</p></li><li><p><strong>Inserting Vectors:</strong> We insert two vectors into the index, each with an ID and a set of float values. This simulates the process of adding data points to the index.</p></li><li><p><strong>Querying the Index:</strong> We perform a vector search by providing a query vector and specifying options such as the number of similar vectors to retrieve (TopK).</p></li><li><p><strong>Printing the Results:</strong> We print the IDs and similarity scores of the most similar vectors found in the search.</p></li></ol><h2 id=retrieval-augmented-generation-with-golang-and-redis>Retrieval Augmented Generation with Golang and Redis<a hidden class=anchor aria-hidden=true href=#retrieval-augmented-generation-with-golang-and-redis>#</a></h2><p>The above code snippet serves as a starting point for implementing vector similarity search in your Go-based AI projects. You can extend this functionality to create recommendation engines, content-based image retrieval systems, or personalized content filtering. In the next example, we&rsquo;ll use the <a href=https://github.com/henomis/lingoose>Lingoose</a> Go framework to build a <strong>retrieval augmented generation (RAG)</strong> system that uses Redis to store and search for similar vectors.</p><h3 id=loading-pdf-documents>Loading PDF Documents<a hidden class=anchor aria-hidden=true href=#loading-pdf-documents>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>docs</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>loader</span>.<span style=color:#a6e22e>NewPDFToTextLoader</span>(<span style=color:#e6db74>&#34;./kb&#34;</span>).
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>WithTextSplitter</span>(<span style=color:#a6e22e>textsplitter</span>.<span style=color:#a6e22e>NewRecursiveCharacterTextSplitter</span>(<span style=color:#ae81ff>2000</span>, <span style=color:#ae81ff>200</span>)).
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Load</span>(<span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Background</span>())
</span></span></code></pre></div><p>The code begins by loading PDF documents from a directory and splitting their text into smaller chunks of 2000 characters. This is a crucial step because it prepares the documents for indexing and querying. The <a href=https://github.com/henomis/lingoose>Lingoose</a> <code>loader</code>, <code>textsplitter</code> packages are used here to facilitate this process.</p><h3 id=creating-a-redis-vector-index>Creating a Redis Vector Index<a hidden class=anchor aria-hidden=true href=#creating-a-redis-vector-index>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// Create a new Redis vector index
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>index</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>index</span>.<span style=color:#a6e22e>New</span>(
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>redis</span>.<span style=color:#a6e22e>New</span>(
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>redis</span>.<span style=color:#a6e22e>Options</span>{
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>RedisearchClient</span>: <span style=color:#a6e22e>redisearch</span>.<span style=color:#a6e22e>NewClient</span>(<span style=color:#e6db74>&#34;localhost:6379&#34;</span>, <span style=color:#e6db74>&#34;test&#34;</span>),
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>CreateIndex</span>: <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>redis</span>.<span style=color:#a6e22e>CreateIndexOptions</span>{
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>Dimension</span>: <span style=color:#ae81ff>1536</span>,
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>Distance</span>:  <span style=color:#a6e22e>redis</span>.<span style=color:#a6e22e>DistanceCosine</span>,
</span></span><span style=display:flex><span>            },
</span></span><span style=display:flex><span>        },
</span></span><span style=display:flex><span>    ),
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>openaiembedder</span>.<span style=color:#a6e22e>New</span>(<span style=color:#a6e22e>openaiembedder</span>.<span style=color:#a6e22e>AdaEmbeddingV2</span>),
</span></span><span style=display:flex><span>).<span style=color:#a6e22e>WithIncludeContents</span>(<span style=color:#66d9ef>true</span>)
</span></span></code></pre></div><p>Next, we create a Redis vector index. We&rsquo;ve specified parameters such as the dimension (1536) and the distance metric (Cosine) in order to be compliant with our AI LLM engine. The <a href=https://github.com/henomis/lingoose>Lingoose</a> <code>openaiembedder</code> package is employed to embed text into vectors, which is essential for AI-based searching. We also set <code>WithIncludeContents</code> to true to include the document contents in the index.</p><h3 id=loading-documents-into-the-index>Loading Documents into the Index<a hidden class=anchor aria-hidden=true href=#loading-documents-into-the-index>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>index</span>.<span style=color:#a6e22e>LoadFromDocuments</span>(<span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Background</span>(), <span style=color:#a6e22e>docs</span>)
</span></span></code></pre></div><p>Here, we load the documents we previously prepared into the Redis index. This step is where the AI embedding of document content happens, allowing us to perform vector-based searches later.</p><h3 id=querying-the-index-with-qa>Querying the Index with Q&amp;A<a hidden class=anchor aria-hidden=true href=#querying-the-index-with-qa>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>qapipeline</span>.<span style=color:#a6e22e>New</span>(<span style=color:#a6e22e>openai</span>.<span style=color:#a6e22e>NewChat</span>().<span style=color:#a6e22e>WithVerbose</span>(<span style=color:#66d9ef>true</span>)).
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>WithIndex</span>(<span style=color:#a6e22e>index</span>).
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Query</span>(<span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Background</span>(), <span style=color:#e6db74>&#34;What is the NATO purpose?&#34;</span>, <span style=color:#a6e22e>option</span>.<span style=color:#a6e22e>WithTopK</span>(<span style=color:#ae81ff>1</span>))
</span></span></code></pre></div><p>The final part of the code demonstrates how to use a Q&amp;A pipeline to query the index. We create a Q&amp;A pipeline using OpenAI LLM, and with the help of the <code>WithInde</code> method, we associate it with our Redis index. We then ask a question, &ldquo;What is the NATO purpose?,&rdquo; and specify that we want the top 1 answer (<code>WithTopK(1)</code>).</p><h2 id=the-ai-powered-search-engine-in-action>The AI-Powered Search Engine in Action<a hidden class=anchor aria-hidden=true href=#the-ai-powered-search-engine-in-action>#</a></h2><p>So, what does this code snippet achieve? It creates an AI-powered search engine capable of answering questions based on the content of PDF documents. When you pose a question, the search engine scans the indexed documents, computes vector-based similarity, and returns the most relevant answer. This approach is highly versatile and can be used in various real-world scenarios, such as:</p><ul><li><p><strong>Document Search</strong>: Build a document search engine that helps users find specific information within a large repository of documents.</p></li><li><p><strong>Chatbots and Virtual Assistants</strong>: Enhance chatbots and virtual assistants by enabling them to answer user questions with accuracy, drawing information from knowledge bases.</p></li><li><p><strong>E-Learning Platforms</strong>: Create intelligent e-learning platforms that can provide instant answers to students&rsquo; queries from course materials.</p></li><li><p><strong>Customer Support</strong>: Improve customer support systems by automating responses to common questions, providing faster and more accurate support.</p></li></ul><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>In this blog post, we&rsquo;ve explored a Go code that demonstrates the power of combining AI, Redis, and OpenAI to create an intelligent search engine. By embedding document content into vectors and using AI models for querying, you can build a versatile and accurate search engine for a wide range of applications. We used the <a href=https://github.com/henomis/lingoose>Lingoose</a> Go framework that I personally developed to provide a simple and efficient way to integrate AI into your Go projects.
Experiment with the code and adapt it to your specific needs to unlock the full potential of AI-powered search. AI is constantly evolving, and its applications are limitless, making it an exciting field for tech-savvy Go programmers. Happy coding!</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://simonevellei.com/blog/tags/lingoose/>lingoose</a></li><li><a href=https://simonevellei.com/blog/tags/ai/>ai</a></li><li><a href=https://simonevellei.com/blog/tags/openai/>openai</a></li><li><a href=https://simonevellei.com/blog/tags/rag/>rag</a></li><li><a href=https://simonevellei.com/blog/tags/llm/>llm</a></li></ul><nav class=paginav><a class=next href=https://simonevellei.com/blog/posts/la-dichiarazione-di-bletchley/><span class=title>Pag Succ »</span><br><span>La Dichiarazione Di Bletchley</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Leveraging Go and Redis for Efficient Retrieval Augmented Generation on twitter" href="https://twitter.com/intent/tweet/?text=Leveraging%20Go%20and%20Redis%20for%20Efficient%20Retrieval%20Augmented%20Generation&amp;url=https%3a%2f%2fsimonevellei.com%2fblog%2fposts%2fleveraging-go-and-redis-for-efficient-retrieval-augmented-generation%2f&amp;hashtags=lingoose%2cai%2copenai%2crag%2cllm"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Leveraging Go and Redis for Efficient Retrieval Augmented Generation on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fsimonevellei.com%2fblog%2fposts%2fleveraging-go-and-redis-for-efficient-retrieval-augmented-generation%2f&amp;title=Leveraging%20Go%20and%20Redis%20for%20Efficient%20Retrieval%20Augmented%20Generation&amp;summary=Leveraging%20Go%20and%20Redis%20for%20Efficient%20Retrieval%20Augmented%20Generation&amp;source=https%3a%2f%2fsimonevellei.com%2fblog%2fposts%2fleveraging-go-and-redis-for-efficient-retrieval-augmented-generation%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Leveraging Go and Redis for Efficient Retrieval Augmented Generation on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fsimonevellei.com%2fblog%2fposts%2fleveraging-go-and-redis-for-efficient-retrieval-augmented-generation%2f&title=Leveraging%20Go%20and%20Redis%20for%20Efficient%20Retrieval%20Augmented%20Generation"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Leveraging Go and Redis for Efficient Retrieval Augmented Generation on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fsimonevellei.com%2fblog%2fposts%2fleveraging-go-and-redis-for-efficient-retrieval-augmented-generation%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Leveraging Go and Redis for Efficient Retrieval Augmented Generation on whatsapp" href="https://api.whatsapp.com/send?text=Leveraging%20Go%20and%20Redis%20for%20Efficient%20Retrieval%20Augmented%20Generation%20-%20https%3a%2f%2fsimonevellei.com%2fblog%2fposts%2fleveraging-go-and-redis-for-efficient-retrieval-augmented-generation%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Leveraging Go and Redis for Efficient Retrieval Augmented Generation on telegram" href="https://telegram.me/share/url?text=Leveraging%20Go%20and%20Redis%20for%20Efficient%20Retrieval%20Augmented%20Generation&amp;url=https%3a%2f%2fsimonevellei.com%2fblog%2fposts%2fleveraging-go-and-redis-for-efficient-retrieval-augmented-generation%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://simonevellei.com/blog>Simone Vellei Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>